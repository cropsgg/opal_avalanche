from __future__ import annotations

from pathlib import Path
from typing import Any, Dict, List
from datetime import datetime
import re

from app.core.config import get_settings


def export_docx(run_id: str, payload: Dict[str, Any]) -> str:
    """Export a professional legal document in DOCX format"""
    
    # Import lazily to avoid hard dependency
    import docx  # type: ignore
    from docx.shared import Inches, Pt
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    from docx.enum.style import WD_STYLE_TYPE

    base = Path(get_settings().EXPORT_TMP_DIR)
    base.mkdir(parents=True, exist_ok=True)
    p = base / f"legal-report-{run_id}.docx"
    
    # Create document with professional styling
    doc = docx.Document()
    
    # Configure page margins
    sections = doc.sections
    for section in sections:
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1.25)
        section.right_margin = Inches(1)
    
    # Add custom styles
    _add_custom_styles(doc)
    
    # Header section
    _add_header_section(doc, run_id, payload)
    
    # Query section
    _add_query_section(doc, payload)
    
    # Analysis section
    _add_analysis_section(doc, payload)
    
    # Verification section
    _add_verification_section(doc, payload)
    
    # Citations section
    _add_citations_section(doc, payload)
    
    # Appendix with source materials
    _add_appendix_section(doc, payload)
    
    # Footer
    _add_footer_section(doc, run_id)
    
    doc.save(str(p))
    return str(p)


def _add_custom_styles(doc):
    """Add custom styles for legal document formatting"""
    
    styles = doc.styles
    
    # Legal heading style
    try:
        legal_heading = styles.add_style('LegalHeading', WD_STYLE_TYPE.PARAGRAPH)
        legal_heading.font.name = 'Times New Roman'
        legal_heading.font.size = Pt(14)
        legal_heading.font.bold = True
        legal_heading.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER
        legal_heading.paragraph_format.space_after = Pt(12)
    except ValueError:
        pass  # Style already exists
    
    # Citation style
    try:
        citation_style = styles.add_style('Citation', WD_STYLE_TYPE.PARAGRAPH)
        citation_style.font.name = 'Times New Roman'
        citation_style.font.size = Pt(10)
        citation_style.font.italic = True
        citation_style.paragraph_format.left_indent = Inches(0.5)
        citation_style.paragraph_format.space_before = Pt(6)
    except ValueError:
        pass
    
    # Legal body text
    try:
        legal_body = styles.add_style('LegalBody', WD_STYLE_TYPE.PARAGRAPH)
        legal_body.font.name = 'Times New Roman'
        legal_body.font.size = Pt(12)
        legal_body.paragraph_format.line_spacing = 1.5
        legal_body.paragraph_format.space_after = Pt(6)
        legal_body.paragraph_format.first_line_indent = Inches(0.5)
    except ValueError:
        pass


def _add_header_section(doc, run_id: str, payload: Dict[str, Any]):
    """Add professional header section"""
    
    # Title
    title = doc.add_heading('LEGAL ANALYSIS REPORT', level=0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Subtitle
    subtitle = doc.add_paragraph('Generated by OPAL Legal AI Assistant')
    subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
    subtitle.runs[0].font.size = Pt(11)
    subtitle.runs[0].italic = True
    
    doc.add_paragraph()  # Spacing
    
    # Report details table
    table = doc.add_table(rows=4, cols=2)
    table.style = 'Table Grid'
    
    # Report ID
    table.cell(0, 0).text = 'Report ID:'
    table.cell(0, 1).text = run_id
    
    # Generated on
    table.cell(1, 0).text = 'Generated On:'
    table.cell(1, 1).text = datetime.now().strftime('%B %d, %Y at %I:%M %p')
    
    # Query mode
    table.cell(2, 0).text = 'Query Mode:'
    table.cell(2, 1).text = payload.get('mode', 'General').title()
    
    # Verification Status
    verification = payload.get('verification', {})
    table.cell(3, 0).text = 'Verification Status:'
    status = verification.get('verification_level', 'Unknown').title()
    confidence = verification.get('confidence', 0)
    table.cell(3, 1).text = f"{status} ({confidence:.1%} confidence)"
    
    doc.add_page_break()


def _add_query_section(doc, payload: Dict[str, Any]):
    """Add query section"""
    
    doc.add_heading('QUERY', level=1)
    
    query_text = payload.get('query', 'No query provided')
    para = doc.add_paragraph(query_text)
    para.style = 'LegalBody'
    
    doc.add_paragraph()


def _add_analysis_section(doc, payload: Dict[str, Any]):
    """Add analysis section with structured format"""
    
    doc.add_heading('LEGAL ANALYSIS', level=1)
    
    answer = payload.get('answer', 'No analysis provided')
    
    # Structure the analysis using IRAC format if possible
    structured_analysis = _structure_analysis(answer)
    
    for section_name, content in structured_analysis.items():
        if content.strip():
            doc.add_heading(section_name, level=2)
            para = doc.add_paragraph(content)
            para.style = 'LegalBody'
    
    # Agent analysis breakdown
    agent_results = payload.get('agent_results', {})
    if agent_results:
        doc.add_heading('EXPERT AGENT ANALYSIS', level=2)
        
        for agent_name, result in agent_results.items():
            doc.add_heading(f"{agent_name.title()} Agent", level=3)
            
            reasoning = result.get('reasoning', 'No reasoning provided')
            para = doc.add_paragraph(reasoning)
            para.style = 'LegalBody'
            
            confidence = result.get('confidence', 0)
            conf_para = doc.add_paragraph(f"Confidence: {confidence:.1%}")
            conf_para.runs[0].font.size = Pt(10)
            conf_para.runs[0].italic = True


def _add_verification_section(doc, payload: Dict[str, Any]):
    """Add verification section"""
    
    verification = payload.get('verification', {})
    if not verification:
        return
    
    doc.add_heading('VERIFICATION REPORT', level=1)
    
    # Overall status
    status = verification.get('verification_level', 'Unknown')
    confidence = verification.get('confidence', 0)
    
    status_para = doc.add_paragraph()
    status_para.add_run('Overall Status: ').bold = True
    status_para.add_run(f"{status.title()} ({confidence:.1%} confidence)")
    
    # Individual check results
    individual_results = verification.get('individual_results', {})
    if individual_results:
        doc.add_heading('Individual Verification Checks', level=2)
        
        table = doc.add_table(rows=1, cols=3)
        table.style = 'Table Grid'
        
        # Header row
        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = 'Check Type'
        hdr_cells[1].text = 'Status'
        hdr_cells[2].text = 'Confidence'
        
        for check_name, result in individual_results.items():
            row_cells = table.add_row().cells
            row_cells[0].text = check_name.title()
            row_cells[1].text = 'Pass' if result.get('valid') else 'Fail'
            row_cells[2].text = f"{result.get('confidence', 0):.1%}"
    
    # Flags and warnings
    flags = verification.get('flags', [])
    if flags:
        doc.add_heading('Verification Issues', level=2)
        for flag in flags[:5]:  # Limit to top 5 issues
            para = doc.add_paragraph(f"• {flag.replace('_', ' ').title()}", style='List Bullet')


def _add_citations_section(doc, payload: Dict[str, Any]):
    """Add citations section with proper legal formatting"""
    
    citations = payload.get('citations', [])
    if not citations:
        return
    
    doc.add_heading('AUTHORITIES CITED', level=1)
    
    # Group citations by court
    citations_by_court = {}
    for citation in citations:
        court = citation.get('court', 'Other')
        if court not in citations_by_court:
            citations_by_court[court] = []
        citations_by_court[court].append(citation)
    
    # Supreme Court first, then High Courts, then others
    court_order = ['SC'] + sorted([c for c in citations_by_court.keys() if c.startswith('HC-')]) + \
                  sorted([c for c in citations_by_court.keys() if c not in ['SC'] and not c.startswith('HC-')])
    
    for court in court_order:
        if court in citations_by_court:
            doc.add_heading(f"{_format_court_name(court)}", level=2)
            
            for i, citation in enumerate(citations_by_court[court], 1):
                cite_para = doc.add_paragraph()
                cite_para.style = 'Citation'
                
                # Format citation
                citation_text = f"{i}. "
                
                title = citation.get('title', 'Unknown Case')
                neutral_cite = citation.get('neutral_cite', '')
                reporter_cite = citation.get('reporter_cite', '')
                
                citation_text += title
                if neutral_cite:
                    citation_text += f" {neutral_cite}"
                if reporter_cite:
                    citation_text += f"; {reporter_cite}"
                
                cite_para.add_run(citation_text)


def _add_appendix_section(doc, payload: Dict[str, Any]):
    """Add appendix with source material excerpts"""
    
    sources = payload.get('retrieval_set', [])
    if not sources:
        return
    
    doc.add_page_break()
    doc.add_heading('APPENDIX - SOURCE MATERIALS', level=1)
    
    for i, source in enumerate(sources[:5], 1):  # Limit to top 5 sources
        doc.add_heading(f"Source {i}", level=2)
        
        # Source details
        title = source.get('title', 'Unknown Authority')
        court = source.get('court', 'Unknown Court')
        
        details_para = doc.add_paragraph()
        details_para.add_run('Authority: ').bold = True
        details_para.add_run(title)
        details_para.add_run('\nCourt: ').bold = True
        details_para.add_run(_format_court_name(court))
        
        # Relevant text
        text = source.get('text', 'No text available')
        if len(text) > 1000:
            text = text[:1000] + "..."
        
        doc.add_paragraph()
        doc.add_paragraph('Relevant Text:').runs[0].bold = True
        text_para = doc.add_paragraph(text)
        text_para.runs[0].font.size = Pt(10)
        text_para.runs[0].italic = True


def _add_footer_section(doc, run_id: str):
    """Add footer with disclaimers"""
    
    doc.add_paragraph()
    doc.add_paragraph('_' * 80)
    
    disclaimer = doc.add_paragraph()
    disclaimer.add_run('DISCLAIMER: ').bold = True
    disclaimer.add_run('This report is generated by AI and is intended for informational purposes only. '
                      'It should not be considered as legal advice. Please consult with a qualified attorney '
                      'for specific legal matters.')
    disclaimer.runs[1].font.size = Pt(9)
    disclaimer.runs[1].italic = True
    
    footer = doc.add_paragraph(f'Generated by OPAL Legal AI • Report ID: {run_id} • {datetime.now().strftime("%Y-%m-%d %H:%M")}')
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
    footer.runs[0].font.size = Pt(8)


def _structure_analysis(answer: str) -> Dict[str, str]:
    """Structure the analysis using IRAC format where possible"""
    
    # Try to identify IRAC components
    sections = {
        'ISSUE': '',
        'RULE': '',
        'APPLICATION': '',
        'CONCLUSION': ''
    }
    
    # Look for common legal analysis patterns
    patterns = {
        'ISSUE': [r'issue.*?(?:is|whether)', r'question.*?(?:is|whether)', r'matter.*?(?:is|whether)'],
        'RULE': [r'(?:section|article|rule|law|statute|provision)', r'(?:held|established|provides)'],
        'APPLICATION': [r'(?:applying|in this case|here|facts|circumstances)', r'(?:analysis|consideration)'],
        'CONCLUSION': [r'(?:therefore|thus|accordingly|conclusion|result)', r'(?:find|hold|decide)']
    }
    
    # If analysis is structured with clear sections, preserve that
    if any(header in answer.upper() for header in ['ISSUE:', 'RULE:', 'APPLICATION:', 'CONCLUSION:']):
        return _parse_structured_analysis(answer)
    
    # Otherwise, provide the full analysis as APPLICATION
    sections['APPLICATION'] = answer
    
    return sections


def _parse_structured_analysis(answer: str) -> Dict[str, str]:
    """Parse analysis that already has IRAC structure"""
    
    sections = {
        'ISSUE': '',
        'RULE': '',
        'APPLICATION': '',
        'CONCLUSION': ''
    }
    
    current_section = 'APPLICATION'  # Default
    
    for line in answer.split('\n'):
        line = line.strip()
        if not line:
            continue
            
        # Check if this line is a section header
        for section in sections.keys():
            if line.upper().startswith(section + ':') or line.upper().startswith('**' + section):
                current_section = section
                # Remove the header from the line
                line = re.sub(r'^(\*\*)?' + section + r'(\*\*)?:?\s*', '', line, flags=re.IGNORECASE)
                break
        
        if line:
            if sections[current_section]:
                sections[current_section] += '\n'
            sections[current_section] += line
    
    return sections


def _format_court_name(court_code: str) -> str:
    """Format court code to full court name"""
    
    court_names = {
        'SC': 'Supreme Court of India',
        'HC-DEL': 'Delhi High Court',
        'HC-BOM': 'Bombay High Court',
        'HC-CAL': 'Calcutta High Court',
        'HC-MAD': 'Madras High Court',
        'HC-KAR': 'Karnataka High Court',
        'HC-GUJ': 'Gujarat High Court',
        'HC-RAJ': 'Rajasthan High Court',
        'HC-MP': 'Madhya Pradesh High Court',
        'HC-UP': 'Allahabad High Court',
        'HC-CHD': 'Punjab & Haryana High Court',
        'HC-KER': 'Kerala High Court',
        'HC-AP': 'Andhra Pradesh High Court',
        'HC-TS': 'Telangana High Court'
    }
    
    return court_names.get(court_code, court_code)


